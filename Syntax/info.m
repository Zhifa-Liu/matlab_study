goods = [
1	13	2.50	0.0316
2	18	0.50	0.0354
3	31	1.18	0.0240
4	26	1.56	0.0350
5	21	2.15	0.0305
6	14	1.72	0.0100
7	17	1.38	0.0109
8	23	1.40	0.0426
9	32	0.70	0.0481
10	38	1.33	0.0219
11	45	1.10	0.0287
12	43	0.95	0.0228
13	39	2.56	0.0595
14	45	2.28	0.0301
15	42	2.85	0.0190
16	43	1.70	0.0782
17	32	0.25	0.0412
18	36	1.79	0.0184
19	27	2.45	0.0445
20	24	2.93	0.0420
21	31	0.80	0.0108
22	27	2.25	0.0018
23	26	1.57	0.0210
24	34	2.80	0.0103
25	40	1.14	0.0155
26	45	0.68	0.0382
27	49	1.35	0.0144
28	32	0.52	0.0020
29	23	2.91	0.0487
30	16	1.20	0.0429
31	1	1.26	0.0250
32	2	1.15	0.0501
33	3	1.63	0.0483
34	4	1.23	0.0006
35	5	1.41	0.0387
36	6	0.54	0.0067
37	7	0.70	0.0129
38	8	0.76	0.0346
39	9	2.14	0.0087
40	10	1.07	0.0124
41	11	1.37	0.0510
42	12	2.39	0.0428
43	13	0.99	0.0048
44	14	1.66	0.0491
45	15	0.45	0.0209
46	16	2.04	0.0098
47	17	1.95	0.0324
48	18	2.12	0.0554
49	19	3.87	0.0262
50	20	2.01	0.0324
51	21	1.38	0.0419
52	22	0.39	0.0001
53	23	1.66	0.0502
54	24	1.24	0.0534
55	25	2.41	0.0012
56	26	1.26	0.0059
57	27	0.42	0.0224
58	28	1.72	0.0580
59	29	1.34	0.0372
60	30	0.06	0.0402
61	31	0.60	0.0274
62	32	2.19	0.0503
63	33	1.89	0.0494
64	34	1.81	0.0325
65	35	1.00	0.0055
66	36	1.24	0.0177
67	37	2.51	0.0361
68	38	2.04	0.0110
69	39	1.07	0.0440
70	40	0.49	0.0329
71	41	0.51	0.0094
72	42	1.38	0.0455
73	43	1.31	0.0121
74	44	1.26	0.0005
75	45	0.98	0.0413
76	46	1.35	0.0241
77	47	2.12	0.0230
78	48	0.54	0.0542
79	49	1.01	0.0566
80	50	1.12	0.0284
81	25	0.79	0.0011
82	46	2.12	0.0492
83	32	2.77	0.0034
84	23	2.29	0.0054
85	20	0.21	0.0490
86	25	1.29	0.0088
87	19	1.12	0.0249
88	41	0.90	0.0038
89	46	2.38	0.0434
90	37	1.42	0.0020
91	32	1.01	0.0300
92	33	2.51	0.0133
93	36	1.17	0.0020
94	38	1.82	0.0308
95	17	0.33	0.0345
96	11	0.30	0.0172
97	15	4.43	0.0536
98	12	0.24	0.0056
99	10	1.38	0.0175
100	7	1.98	0.0493
];
part=goods(1:30,:);
part_w=sum(part(:,3));
part_v=sum(part(:,4));
locations = [
9185	500
1445	560
7270	570
3735	670
2620	995
10080	1435
10025	2280
7160	2525
13845	2680
11935	3050
7850	3545
6585	4185
7630	5200
13405	5325
2125	5975
15365	7045
14165	7385
8825	8075
5855	8165
780	    8355
12770	8560
2200	8835
14765	9055
7790	9330
4435	9525
10860	9635
10385	10500
565	    9765
2580	9865
1565	9955
9395	10100
14835	10365
1250	10900
7280	11065
15305	11375
12390	11415
6410	11510
13915	11610
9510	12050
8345	12300
4930	13650
13265	14145
14180	14215
3030	15060
10915	14235
2330	14500
7735	14550
885	    14880
11575	15160
8010	15325
11000   8250
];
connections=[
1	3
1	8
2	20
2	4
3	8
3	4
4	2
5	15
5	2
6	1
7	18
7	1
8	12
9	14
9	10
10	18
10	7
11	12
12	13
12	25
12	15
13	18
13	19
13	11
14	18
14	16
14	17
14	21
15	22
15	25
16	23
17	23
18	31
19	24
20	22
21	26
21	36
21	17
22	30
23	17
24	31
25	41
25	19
25	29
27	31
28	33
29	22
30	28
30	41
31	26
31	34
32	35
32	23
33	46
33	28
34	40
35	38
36	45
36	27
37	40
38	36
39	27
40	34
40	45
41	44
41	37
41	46
42	43
42	49
43	38
44	48
44	50
45	50
45	42
46	48
47	40
48	44
49	50
49	42
50	40
21  51
18  51
26  51
];
%邻接矩阵
part=sparse(reshape(connections(:,1),1,83),reshape(connections(:,2),1,83),ones(1,83),51,51);
C=part+part';
C(C~=0)=1;
C=full(C);
%权值邻接矩阵(即Flod求任意两点最短距离矩阵的初值)
W=zeros(51,51);
for i=1:51
    for j=1:51
        if C(i,j)==1
            W(i,j)=sqrt((locations(i,1)-locations(j,1))^2+(locations(i,2)-locations(j,2))^2);
        end
        if C(i,j)==0&&i~=j
            W(i,j)=Inf;
        end
    end
end
%绘制图像
plot(locations(:,1),locations(:,2),'o');
for i=1:51
    text(locations(i,1),locations(i,2),num2str(i));
end
hold on;
for i=1:30
    plot(locations(goods(i,2),1),locations(goods(i,2),2),'ro');
end
hold on;
plot(locations(51,1),locations(51,2),'r*');
hold on;
gplot(C,locations);

%第一问：贪婪算法求解: can't slove because the existence of inf
% node=[13,14,16,17,18,21,23,24,26,27,31,32,34,36,38,39,40,42,43,45,49,51];%第一问涉及结点
% route=zeros(1,22);%用于存储贪婪算法求解到的路径
% process=[22,1:21];
% W_1=W(node,node);%第一问涉及结点的距离(权值)矩阵
% 
% route(1)=node(22);%初始结点 a=1:(22-1) part1
% cur=22;%贪婪算法的当前点
% tot_dis=0;
% for a=1:20
%     process(:,1)=[];%清除上次迭代的最优点
%     distance=zeros(1,22-a);
%     for i=1:22-a
%         distance(i)=W_1(cur,process(i));
%     end
%     %对于贪婪算法当前点与其它点的最小值(最优点对应值);
%     cur_min=min(distance);
%     %求最优点下标
%     index=1;
%     for j=1:22-a
%         if distance(j)==cur_min
%             index=j;
%             tot_dis=tot_dis+cur_min;
%             break;
%         end
%     end
%     %最优点交换到前面
%     temp=process(1);
%     process(1)=index;
%     process(index)=temp;
%     %最优点存入路径
%     cur=process(1);
%     route(a+1)=node(process(1));
% end
% route(index)=process(1);%a=1:(22-1-1) part2  ---> a=1:20
% route;
% tot_dis;

%第一问：Flod与贪婪算法求解
%W_1=W(node,node);
n=size(W,1);
D=W;%赋初值
R=zeros(n);
for i=1:n
    for j=1:n
        R(i,j)=j;
    end
end
%Flod算法计算最短距离矩阵
for k=1:n
    for i=1:n
        for j=1:n
            if D(i,k)+D(k,j)<D(i,j)
                D(i,j)=D(i,k)+D(k,j);
                R(i,j)=k;
            end
        end
    end
end
%根据最短距离矩阵求解最短路径
nodes=[13,14,16,17,18,21,23,24,26,27,31,32,34,36,38,39,40,42,43,45,49];%第一问涉及的送货点编号
route=zeros(1,45);%用于存储路径
cur=51;%当前点,51代表起始点
a=1;
route(a)=51;
tot_dis=0;
from=cur;
end_node=0;
while ~isempty(nodes)
    distance=D(cur,nodes);
    %求当前点与其它未经过点距离的最小值(最优点对应值)对应点下标;
    index=find(distance==min(distance));
    from=cur;
    end_node=nodes(index);
    while 1
        a=a+1;
        if R(from,end_node)~=end_node
            old_from=from;
            from=R(old_from,end_node);
            route(a)=from;
            tot_dis=tot_dis+D(old_from,from);
            nodes=nodes(nodes~=from);
        else
            route(a)=end_node;
            tot_dis=tot_dis+D(from,end_node);
            cur=end_node;
            nodes=nodes(nodes~=end_node);
            break;
        end
    end
end
route(a+1)=51;
%tot_dis=tot_dis+D(end_node,51);
route
tot_dis


